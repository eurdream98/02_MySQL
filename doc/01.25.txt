01.25
DATA_TYPES
MySQL데이터 유형 : 문자열, 숫자, 날짜, 시간

숫자 
정수 : INT INTEGER보편적으로 많이 쓰임
실수 : FLOAT, DOUBLE -> 근사치이기 때문에 정확한 수치로 저장하고 싶다면 DECIMAL을 이용하여 실수형으로 바꿔준다. 

BIT(N) : 비트 단위로 데이터 저장할 때 쓰는 데이터 형식

문자
CHAR 고정길이형 문자 INSERT,DELETE에서 효율적
VARCHAR 가변길이 문자형

파일은 따로 저장하는 경우가 많기 때문에 TEXT,BLOB계열은 주로 사용 X

ENUM은 CHECK처럼 어떤 값들만 들어갈 수 있다고 한정해주는 효과이다. 

SET은 ('A','B','C')일 때 A,B,C,AB,AC,BC,ABC,NULL값이 가능한 데이터 타입이다. 

날짜와 시간 데이터 형식
DATE, TIME, DATETIME

TIMESTAMP는 TIMEZONE에 맞게 시간대를 변환하여 저장해줌

GEOMETRY : 선,점을 저장
JSON : JSON파일을 저장

SIGNED INTEGER : 부호가 있는 정수로 형변환할 때 

CAST(변환하고 싶은 인자 AS 변환형)
CONVERT(변환하고 싶은 인자, 변환형)
CAST('2023/5/30' AS DATE); ->DATE형으로 바꿈

자동으로 형변환 되는 경우도 있다.

CONCAT 혹은 +를통해 정수와 숫자를 합치면 숫자가 정수형으로 암시적으로 바뀐다. 

문자와 숫자의 비교에서 문자는 0으로 변환 됨

SELECT 5 > '6MAY'; -- 문자에서 첫번째로 나온 숫자는 정수로 전환된다. '6MAY'가 숫자 6으로 자동변환 됨

-------------------------------------------------------------------------------------------------

내장 함수

문자열,숫자,날짜,시간을 가공하는 내장함수들 제공
1. 문자열 관련 함수
ASCII(아스키코드) : 아스키 코드 값 추출, CHAR(숫자) : 아스키 코드로 문자 추출
CONCAT(), CONCATWS(),ELT(), FIELD,FIND_INSET():콤마 기준으로 나뉘어있을 경우,

FORMAT : 1000단위마다 콤마 표시를 해 주며 소수점 아래 자리수까지 표현한다.

---------------------------------------------------------------------------------------------------

테이블 외에 자료를 저장할 수 있는 객체 VIEW와 INDEX

VIEW
가상테이블이라고 불린다. CREATE TABLE은 실제 데이터 저장공간을 물리적으로 할당한 것이지만 VIEW는 물리적으로 저장하지 않고 쿼리만 저장했지만 테이블을 사용하는 것과 동일하게 사용할 수 있는 논리 테이블이다. 

VIEW를 통해 복잡한 SELECT문 없이 자료를 찾을 수 있다.
각각의 객체들에 대한 세부 권한을 부여해줄 수 있다. 테이블에 민감한 내용이 있다면 그 부분을 제외한 테이블을 뷰로 만들어 접근권한을 나눠서 분리함.

VIEW 생성 -> CREATE VIEW 뷰이름 AS 베이스테이블(원본테이블에서 조건에 따라 추출한 테이블)

베이스 테이블 에 해당하는 자료를 넣어도 view에 적용이 자동으로 됨(동기화)반대로 VIEW에 자료를 넣어도 베이스테이블에 마찬가지로 자료가 삽입됨

뷰와 원본테이블이 연결되어 삽입,수정,삭제가 동기화 되어 일어남 

하지만 사용된 서브쿼리에 따라 DMB명령어로 조작이 불가능할 수 있다. 
VIEW가 만들어질 수는 있지만 삽입,수정,삭제만 불가능한 것이다. 
그래서 조회만 가능한 보안을 위한 READ ONLY VIEW도 존재한다. 

OR REPLACE : CREATE뒤에 붙는다. 만약 이미 VIEW가 존재하는 상태에서 실행하면 교체하게 된다. 

-----------------------------------------------------------------------------------------------------

INDEX

테이블,뷰이외의 또 다른 객체이다. 데이터 검색 속도를 향상시키는 것이 목적이다. 만약 테이블이 있고 WHERE절에있는 조건을 만족하기 위해서 행 하나하나를 살펴보며 조건이 맞는지 확인해야한다.(TABLE FULL SCAN) 

인덱스는 트리구조를 가지고 있다. 트리구조는 정렬된 상태로 만들어진다. 데이터를 찾을 때 물리적인 위치로 찾는 것이아니라 내용을 바탕으로 찾는데 물리적인 위치로 찾는 것이 인덱스이다. (INDEX SCAN)

인덱스는 트리구조에 특정컬럼에 대해 정렬을 해놓은 것이다.  

유니크나 프라이머리키는 내부적으로 인덱스가 만들어진 상태에서 인덱스 탐색을 통해 데이터에 빠르게 접근할 수 있다. 

옵티마이저 
어떻게하면 제일 효율적일까를 결정하는 친구가 옵티마이저이다.
쿼리에 대한 효율적인 실행 계획을 세훈다. 
MySQL은 기본적으로 CBO를 기반으로만 사용하고 RBO는 제공하지 않는다.

비용기반 옵티마이저 (CBO)
비용을 추정하여 쿼리 실행 계획 선택, 자원사용을 고려하고 데이터베이스의 통계 정보를 사용하여 비용을 추정한다. 

규칙기반 옵티마이저(RBO)
미리 규칙을 정해놓고 이럴땐 이렇게 해~라는식으로 효율적인 방법으로 공식화되어있어 떄때로 상황에 따라 비효율적인 쿼리 실행 계획이 선택 될 수 있다. 

EXPLAIN 키워드 : SELECT앞에 붙혀준다. 어떻게 실행할지를 설명
SIMPLE : 서브쿼리,UNION이 없는 경우 
TYPE : ALL = 테이블 전체를 스캔한다.

인덱스 생성 : create index  on 컬럼명
인덱스 확인 : show indx from 테이블명

인덱스 후 explain확인 -> type이 all이 ref로 바뀌였다. 즉 테이블전체스캔에서 인덱스 스캔으로 바뀌였다고 생각하면 된다. 

인덱스 최적화(재구성)
데이터의 변경이 많은 경우 인덱스를 재구성하여 성능을 개선하고 디스크 공간을 더 효율적으로 사용하도록 한다. 

optimize table을 통해 인덱스 최적화할 수 있다. 


인덱스는 트리형태인데 데이터 변경이 많아서 트리의 밸런스가 맞지않아져 원래있던 데이터에서 트리는 밸런스가 맞아야 효율이 나오지만 밸러스 맞는 트리로 만들어준다는 것이다. 

트리(index)에 컬럼 값 뿐만아니라 위치정보가 함께 들어있다. 인덱스가 생성되면 트리를 자동으로 생성해준다.

DBMS 객체 : table,view,index,사용자

---------------------------------------------------------------------------------------------------

모델링

목적에 부합하게 설계도를 만들고 모델링을 해야한다. 

모델링은 만들어야하는 것을 어느정도 그려놓은 것이다. 이 것을 통해 의사소통,시뮬레이션,문제해결등등에 쓰인다.

설계->모델링

데이터가 메모리에서 소멸되지 않고 저장하려면 저장장치가 필요하다. 파일에 저장하고 읽어오는 방식은 여러모로 불편한 점이 많다. -> 파이ㄹ을 데이터베이스로 썼을 때 문제점많음

엑셀로 썼을 경우에는 
중복되는 데이터가 많아지고 중복이 많은 만큼 테이블을 수정할 시 바꿔야할 공간이 많아진다, 한 테이블에 다 넣지 않고 쪼개서 넣는 것을 통해 관계형 데이터베이스를 통해 구현한다. 

폭포수 형태 
요구사항 분석 -> 프로그램 설계 -> 프로그램 구현 -> 통합/테스트 ->유지보수

논리설계->물리설계->DB구축 과정을 거쳐 완료할 것이다. 

프로세스 설계에는 데이터 관점과 프로세스 관점 설계 2가지로 나뉜다. 

데이터 모델 표기법 2가지
1. 바커표기법
2. IE표기법 

무결성 = 모순도 없고 정확해야한다. 

PK,FK,업무무결성 잘 맞출 것

